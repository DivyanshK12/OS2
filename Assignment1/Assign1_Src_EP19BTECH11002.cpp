#include <iostream>
#include <string>
#include <random>
#include <chrono>
#include <pthread.h>

using namespace std;

random_device rd;                                    // obtain a random number from hardware
mt19937 generator(rd());                             // seed the generator
uniform_real_distribution<> distribution(-1.0, 1.0); // define the range

void *thread_function(void *arg);

class Point
{
public:
    float x, y, dist_to_origin;
    Point()
    {
        // creates random point in the unit square
        x = distribution(generator);
        y = distribution(generator);
        dist_to_origin = x * x + y * y; // distance from origin sqr
    }
    bool is_point_in_circle()
    {
        return dist_to_origin <= 1; // point is in unit circle
        // sqrt not needed since sqrt(x) <= 1 is same as x <= 1
    }
    string to_string()
    {
        return "(" + std::to_string(x) + ", " + std::to_string(y) + ")";
    }
};

typedef struct thread_data
{
    int thread_id;
    int num_points;
    int result;
    Point *point_array;
    bool *point_status_array;
} thread_data;

int main(void)
{
    int num_points, thread_count;
    int total_in = 0;
    FILE *inp = fopen("inp.txt", "r");
    fscanf(inp, "%d %d", &num_points, &thread_count); // read input from file
    fclose(inp);

    auto start = chrono::steady_clock::now();                // begin timing from here
    thread_data *data_array = new thread_data[thread_count]; // create instances of function parameter for each thread
    pthread_t *thread_array = new pthread_t[thread_count];   // array to keep track of thread_ids for joining

    // thread creation
    for (int i = 0; i < thread_count; i++)
    {
        thread_data *data = &(data_array[i]);
        data->num_points = num_points / thread_count;
        data->thread_id = i;

        pthread_create(&(thread_array[i]), NULL, thread_function, data); // thread creation
    }

    for (int i = 0; i < thread_count; i++)
    {
        pthread_join(thread_array[i], NULL); // waiting for all threads to finish
    }

    for (int i = 0; i < thread_count; i++)
    {
        total_in += data_array[i].result; // summing up the results to get total points inside circle
    }

    auto end = chrono::steady_clock::now();                                   // end timing here
    auto duration = chrono::duration_cast<chrono::microseconds>(end - start); // calculate time taken in microseconds

    FILE *out = fopen("output.txt", "w");
    fprintf(out, "Time taken by function: %ld microseconds\n", duration.count());
    fprintf(out, "Value computed : %f\n", 4.0 * total_in / num_points);
    fprintf(out, "Log :\n");

    for (int i = 0; i < thread_count; i++) // printing the results
    {
        fprintf(out, "Thread %d : %d in circle, %d in square\n", i, data_array[i].result, num_points / thread_count - data_array[i].result);

        fprintf(out, "Points in circle : ");
        for (int j = 0; j < num_points / thread_count; j++)
        {
            if (data_array[i].point_status_array[j])
                fprintf(out, "%s ", data_array[i].point_array[j].to_string().c_str());
        }
        fprintf(out, "\n");

        fprintf(out, "Points in square : ");
        for (int j = 0; j < num_points / thread_count; j++)
        {
            if (!data_array[i].point_status_array[j])
                fprintf(out, "%s ", data_array[i].point_array[j].to_string().c_str());
        }
        fprintf(out, "\n");
    }
    fclose(out);

    return 0;
}

void *thread_function(void *arg)
{
    thread_data *data = (thread_data *)arg; // access the data passed to this thread
    int num_points = data->num_points;      // number of points to be generated by this thread
    int count = 0;                          // number of points inside circle

    data->point_array = new Point[data->num_points];       // Instantiating array of points
    data->point_status_array = new bool[data->num_points]; // Instantiating array of point-in-circle results

    for (int i = 0; i < num_points; i++)
    {
        auto p = data->point_array[i]; // get the point
        if (p.is_point_in_circle())
        {                                       // check if point is in circle
            data->point_status_array[i] = true; // set the point status to true
            count++;                            // increment count
        }
    }

    data->result = count; // set the result to be accessed by main thread
    return NULL;
}